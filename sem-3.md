# Семинар 3 - Работа с файлами

## ман

Самый крутой источник знаний по системным вызовам находится прямо в вашем компьютере - это команда `man`. Эта команда позволяет прочитать документацию по интересующему вас системному вызову. Например, чтобы открыть документацию по вызову `read`, нужно просто ввести команду `man read`. Иногда это не будет так просто срабатывать: например `man write` выводит доку по команде `write`, а не по системному вызову `write`. Это потому что инфа о системных вызовах лежит на странице 2 (пруф: `man man`) и поэтому надо ввести `man 2 write`.

## Работа с системными вызовами
На самом деле, системный вызов это лишь ассемблерная команда `syscall` или `int 0x80`. Но как вы могли заметить, на ассемблере мы пока ничего не пишем, а системные вызовы мы юзаем как будто это функции из языка C. На самом деле так и есть, мы юзаем обёртки над системными вызовами, которые нам заботливо предоставляет `libc`, и уже внутри перекладывает наши аргументы по нужным местам, вызывает команду `syscall` и прокидывает ошибки в `errno`. Кстати, не для всех системных вызовов `libc` предоставляет обёртку (см. `man futex`, `man syscall`).

## Обработка ошибок
Системные вызовы не всегда заканчиваются успехом. Причины провала могут быть как зависящими от пользователя, так и не зависящими. В любом случае, об этом надо как-то узнавать. В случае ошибки, ядро возвращает из системного вызова отрицательное значение. Библиотечка `libc` бережно перекладывает это значение в "глобальную переменную" `errno` (см. `man errno`) и как правило возвращает -1. Небольшая проблема, что `errno` это просто чиселка, означающая код ошибки. На помощь приходит либо `man errno`, либо `perror` (см. `man perror`), которая расшифровывает код ошибки и пишет его в `stderr` (см. `man stderr`). Поэтому после каждого системного вызова необходимо писать проверку того, не вернул ли он часом -1.

## Файловый дескриптор
Все ваши взаимодействия с файлами в линуксе будут осуществляться через файловые дескрипторы - чиселки, начинающиеся от нуля, обозначающие файлы, открытые вашим процессом. По умолчанию таблица файловых дескрипторов у вашего процесса своя, не пересекающаяся с другими процессами, и содержащая три дескриптора: `STDIN_FILENO` aka 0 - ввод из терминала; `STDOUT_FILENO` aka 1 - поток вывода в терминал; `STDERR_FILENO` - поток вывода ошибок в терминал.
Самый простой способ создать файловый дескриптор - открыть файл с помощью `open` (см. `man open`). Все оболочки типа `FILE*` в C, `std::fstream` в C++ и даже `open` из Python это оболочки над старым добрым файловым дескриптором.

## Попробуем что-нибудь написать
Давайте попробуем создать и открыть файл с помощью системного вызова `open` (см. `man open`) и написать в него что-нибудь с помощью системного вызова `write` (см. `man 2 write`). Инклюды я опущу для краткости.

```c
int main() {
    int fd = open("test.txt", O_WRONLY | O_CREAT, 0644);
    if (fd == -1) {
        perror("open");
        abort();
    }

    ssize_t nwritten = 0;
    const char hello[] = "hello";

    do {
        nwritten = write(fd, hello + nwritten, sizeof(hello) - nwritten);
        if (nwritten == -1) {
            perror("write");
            abort();
        }
    } while (nwritten != sizeof(hello));

    close(fd);
}
```

На что стоит обратить внимание: системные вызовы `read` и `write` не гарантируют, что они запишут/прочитают целый буффер сразу. Поэтому по-хорошему `write` нужно оборачивать вот в такой вот цикл. Это его недостаток по сравнению с `printf`, который можно просто один раз написать и забыть.

## Макрос обработки ошибок
Ошибки обрабатывать надо. После каждого системного вызова надо писать проверку. Руками её писать каждый раз муторно. Поэтому я буду использовать следующий макрос:
```c
#define CHECK_RES(res, desc) do { if (res == -1) { perror(desc); abort(); } } while (0);
```
Вас я использовать его не заставляю, если хотите - можете обрабатывать ошибки по-своему.

## Ходьба по файлу
Когда мы открыли файл, ядро отслеживает, где именно мы в этом файле сейчас находимся: в начале, в середине, в конце... Назовём это положением каретки. Если мы что-то прочитаем с помощью `write`, то наша каретка переместится вправо, и в следующий раз мы уже будем считывать с того места, где мы остановились. Аналогично с `read`. Двигать каретку можно с помощью системного вызова `lseek` (см. `man lseek`). Давайте попробуем решить следующую задачу: увеличить в файле пятый байт на единичку. Поробуем сделать это с помощью `read`, `write` и `lseek`.

```c
int main() {
    int fd = open("test.txt", O_RDWR);
    CHECK_RES(fd, "open");

    off_t sought = lseek(fd, 5, SEEK_SET);
    CHECK_RES(sought, "seek");

    char c;
    int nread = read(fd, &c, 1);
    CHECK_RES(nread, "read");

    c++;

    sought = lseek(fd, 5, SEEK_SET);
    CHECK_RES(sought, "seek");

    int nwrote = write(fd, &c, 1);
    CHECK_RES(nwrote, "write");

    CHECK_RES(close(fd), "close");
}
```

Работает, но громоздко. Для альтернативного решения этой задачи предлагается ознакомиться с вызовами `pread` и `pwrite` (см. `man pread`), которые не трогают каретку, а работают с того оффсета, который им передали.

```c
int main() {
    int fd = open("test.txt", O_RDWR);
    CHECK_RES(fd, "open");

    char c;
    CHECK_RES(pread(fd, &c, 1, 5), "pread");

    c++;

    CHECK_RES(pwrite(fd, &c, 1, 5), "pwrite");

    CHECK_RES(close(fd), "close");
}
```

Ну и для общего развития можно ознакомиться еще и с сисколлом `writev` (см. `man writev`), который может писать сразу много строчек:

```c
int main() {
    const char* const hello[] = {"h", "e", "l", "l", "o", "\n"};
    const int sz = sizeof(hello) / sizeof(hello[0]);

    struct iovec hellos[sz];
    for (int i = 0; i < sz; i++) {
        struct iovec vec = {
            .iov_base = (void*)hello[i], // !
            .iov_len = 1
        };
        hellos[i] = vec;
    }
    CHECK_RES(writev(STDOUT_FILENO, hellos, sz), "writev");
}
```

И с сисколлом `sendfile` (см. `man sendfile`), который может писать из одного файлового дескриптора напрямую в другой, минуя пользователя.

## strace

Вообще, очень часто полезно знать, какие системные вызовы делает программа, и что они возвращают. Для этого есть удобная тулза `strace`, которая умеет прослушивать системные вызовы программы. Давайте попробуем запустить её для нашего примера на `lseek`.

```
$ gcc seek.c -o seek
$ strace ./seek
<тут куча подготовительных системных вызовов>
openat(AT_FDCWD, "test.txt", O_RDWR)    = 3
lseek(3, 5, SEEK_SET)                   = 5
read(3, "6", 1)                         = 1
lseek(3, 5, SEEK_SET)                   = 5
write(3, "7", 1)                        = 1
close(3)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```

Как мы видим, все наши системные вызовы отобразились тут. Очень удобно!

## Смотрим на свойства файлов
Для просмотра свойств файлов (в общем смысле этого слова, т.е. в рамках философии everything-is-a-file) есть очень удобное семейство сисколлов `stat` (см. `man 2 stat`). Он возвращает удобную структурку `struct stat`, которая содержит всю информацию о файле, в том числе информация о том, какой у него тип (о том, как расшифровать содержимое `st_mode`, см. `man inode`).

## Работа с папками
Для работы с папками используются вызовы `opendir`, `mkdir`, `readdir`. Опять же, читаем ман, чтобы понять, что они делают.

## FUSE и procfs
На самом деле, философия everything-is-a-file может заходить очень далеко. Например, есть подсистема `procfs`, которая работает путём создания "ненастоящей" файловой системы, располагающейся по пути `/proc`. В неё можно сходить и посмотреть, например, в файловые дескрипторы, открытые в данный момент в моём процессе терминала. И даже что-нибудь себе самому написать в терминал через этот дескриптор.

```
$ cd /proc/self/fd/
$ ls
0  1  19  2  21  25  255
$ echo "hello" > 1
hello
```

Заметьте, как я написал "hello" в файлик `/proc/self/fd/1`, а вывелось оно мне прямо в терминал. Это потому что дескриптор с номером 1 это `stdout` моего терминала.

Более того, мы сами можем создавать такие файловые системы. Вот [в этой статье](https://habr.com/ru/articles/315654/) показывается, как системные вызовы типа `readdir`, `open`, `read` можно обрабатывать из питона и делать вид что мы и есть файловая система.

Одним из практических применений этой функциональности является возможность маунтить (см. `man 2 mount`) папки с удалённых `ssh`-серверов. То есть вместо `scp` я могу воспользоваться `sshfs` и работать с удалёнными папками, будто они локальные.
