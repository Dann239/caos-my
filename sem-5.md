# Семинар 5 - ARM64 Assembly

Хороший туториал можете почитать [вот тут](https://modexp.wordpress.com/2018/10/30/arm64-assembly/). Из него я брал значительную часть материалов для семинара.

## Настройка среды

Сегодня мы поговорим про архитектуру `ARM64` и как писать под неё код на ассемблере. Если ваш компьютер имеет архитектуру `x86-64`, то для тестирования ваших поделок вам понадобится эмулятор архитектуры `ARM64`. Для этой цели предлагается использовать QEMU, который на Ubuntu устанавливается следующим образом:

```sh
sudo apt install qemu-user gcc-aarch64-linux-gnu
```

Далее, чтобы скомпилировать ваш код, надо попросить об этом установленный вами компилятор:
```sh
$ aarch64-linux-gnu-gcc hello.c
```

И чтобы запустить надо указать QEMU папку, которую необходимо проинтерпретировать как корень файловой системы (так как наш корень содержит библиотеки для `x86-64`, которые очевидно не взлетят):
```sh
$ export QEMU_LD_PREFIX=/usr/aarch64-linux-gnu
```

Теперь можно запустить нашу программу через эмулятор:
```sh
$ qemu-aarch64 ./a.out
```

## Регистры и calling conventions

Аналогично с `x86-64`, в ARM64 применимо понятие регистров. Их назначение в рамках вызовов функций выписано, например, [вот тут](https://stackoverflow.com/a/5467986). В отличие от `x86-64` их легко запомнить: `sp` это stack pointer, `r0`-`r7` это аргументы, `r9`-`r15` - регистры общего назначения, `r19`-`r28` - callee-saved регистры, значение которых нужно восстановить после выхода из функции. Аналогично с `x86-64`, при вызове функции stack pointer `sp` должен быть выровнен на 16 байт, но в отличие от `x86-64`, при вызове функции адрес возврата кладётся не на стек, а в регистр `r30`.

Аналогично с `x86-64`, в зависимости от первой буквы, к регистрам можно обращаться как к 64-битным (`x0`, `x1`, и т.д. для обращения к `r0`, `r1` и т.д.), так и как к 32-битным (`w0`, `w1`, и т.д. для обращения к `r0`, `r1` и т.д.).

## Базовые инструкции

Арифметические операции (их на самом деле гораздо больше, полный список при желании предлагается изучить самостоятельно):
```asm
add x0, x1, x2 // x0 = x1 + x2
sub x0, x1, x2 // x0 = x1 - x2
mul x0, x1, x2 // x0 = x1 * x2
lsl x0, x1, x2 // x0 = x1 << x2
lsr x0, x1, x2 // x0 = x1 >> x2
```

Сравнения и прыжки реализованы аналогично `x86-64`, только `j` (jump) заменена на `b` (branch):
```asm
cmp x0, x1 // сравни x0 и x1

beq label // прыгни на label если x0 == x1
bne label // прыгни на label если x0 != x1
bge label // прыгни на label если x0 >= x1 в знаковом смысле
bhi label // прыгни на label если x0 >= x1 в беззнаковом смысле
// и т.д.
```

Вызов функции осуществляется с помощью `bl` (branch labeled), возврат - аналогично `x86-64`:
```asm
bl printf // вызови printf и положи адрес возврата в x30

ret // осуществи возврат из функции, взяв адрес возврата из x30
```

## Работа с памятью

То, что в `x86-64` мы обозначали инструкцией `mov`, в `ARM64` обозначается чуть более широким спектром инструкций:

```asm
mov x0, x1     // перекладывает значение из одного регистра в другой (x0 = x1)
ldr x0, [x1]   // считывает значение из памяти в регистр (x0 = memory[x1])
str x0, [x1]   // сохраняет значение регистра в память (memory[x1] = x0)
adr x0, printf // сохраняет адрес символа в регистр (x0 = &printf)
```

Аналогично `x86-64`, при формировании адреса можно указать смещение. При необходимости можно умножить смещение на степень двойки с помощью синтаксиса lsl:
```asm
ldr x0, [x1, x2]       // x0 = memory[x1 + x2]
str x0, [x1, x2 lsl 3] // memory[x1 + (x2 << 3)] = x0
```

В отличие от `x86-64`, команды `ldr` и `str` могут изменять значение регистра, с которым они работают. Это можно сделать в двух стилях:
```asm
ldr x0, [x1, 8]! // pre-indexed: x0 = memory[x1 + 8]; x1 += 8
ldr x0, [x1], 8  // post-indexed: x0 = memory[x1]; x1 += 8
```

В ARM64 нет команд `push` и `pop`, но с использованием вышеуказанной техники их легко написать руками:
```asm
ldr x0, [sp], 8   // pop x0
str x0, [sp, -8]! // push x0
```

## Immediate operands и literal pool

Зачастую мы хотим, чтобы один из операндов был не регистром, а числом. `ARM64` разрешает в некоторых случаях заменить регистр на `immediate operand`. Такой операнд записывается как число, перед которым стоит символ `#`. Символ `#` писать не обязательно:
```asm
ldr x0, [sp], #8   // в прошлом параграфе мы на самом деле уже использовали immedate operands
lsl x0, x1, #8     // x0 = x1 << 8
mov x0, #4         // x0 = 4
mov x0, 4          // x0 = 4, но символ # опущен
```

Небольшая проблема: поскольку `ARM64` это RISC архитектура, все инструкции в ней ограничены 32 битами, поэтому размер immediate operands, которые мы можем в них закодировать, сильно ограничен. Но что если мы хотим загрузить в регистр большое число? Ответ в том, что его нужно поместить в секцию `.rodata` и прочитать в рантайме. Для вашего удобства существует синтаксический сахар, который сделает это за вас:
```asm
ldr x0, =100500 // прочитай значение 100500 из literal pool'а и положи его в x0
```

## Syscall ABI

Системный вызов делается с помощью команды `svc 0`. Про то, куда складывать какие аргументы можно прочитать, например, [тут](https://blog.xhyeax.com/2022/04/28/arm64-syscall-table/).

## Примеры

### Вывод `hello` в терминал.
```asm
.text
.globl main
main:
    adr x0, fmt         // первый и единственный аргумент printf это указатель на строчку
    str x30, [sp, -16]! // кладём старый адрес возврата на стек, двигаем верхушку стека на 16 байт, а не на 8, чтобы не нарушить выравнивание
    bl printf
    ldr x30, [sp], 16   // достаём адрес возврата, затем прибавляем к верхушке стека 16, чтобы вернуть её как было
    mov x0, 0
    ret

.rodata
fmt:
.string "hello\n\0"
```
На что обратить внимание: в отличие от `x86-64`, нам надо сберечь адрес возврата `x30` на стеке самостоятельно, так как команда `bl` его перезапишет и мы его потеряем.

### Запуститься без стандартной библиотеки

```asm
#include <sys/syscall.h>

.text
.globl _start
_start:
    mov x8, SYS_write
    mov x0, 1
    adr x1, hello
    mov x2, 6
    svc 0

    mov x0, 0
    mov x8, SYS_exit
    svc 0

.rodata
hello:
.string "hello\n"
```

### Сумма элементов в массиве

```asm
.text
.globl sum_arr
sum_arr: // x0: int64_t* data, x1: int64_t size
    lsl x1, x1, 3 // x1 *= sizeof(int64_t)
    add x1, x0, x1 // x1 = x0 + x1

    mov x2, 0

    loop_begin:
    cmp x0, x1
    beq loop_end
        ldr x3, [x0], 8
        add x2, x2, x3
        b loop_begin
    loop_end:

    mov x0, x2
    ret
```

На что обратить внимание: цикл устроен так, что проверка делается в первую очередь; таким образом, при пустом массиве будет возвращён ноль.
