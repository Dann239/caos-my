# Семинар 1 - Инструменты

## Язык C
В данном курсе используется язык C. Так исторически сложилось, что именно этот язык повсеместно используется для написания близких к железу программ.
Кстати, в последнее время у языка C [появился конкурент](https://www.phoronix.com/news/Rust-Linux-6.3-Changes) в этой нише.

На данном этапе предлагаю вспомнить команду [printf](https://en.cppreference.com/w/c/io/fprintf) и написать нашу первую программу.

```c
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
```

## Сборка с помощью GCC
Написанную на языке C программу нельзя просто так выполнить, её нужно перед этим собрать. Один из способов это сделать это воспользоваться компилятором GCC: вбить в терминале `gcc hello.c`.
Данное действие создаст исполняемый файл `a.out`, так GCC по умолчанию называет исполняемые файлы. Если такое название нас не устраивает, то мы можем попросить назвать его по-другому:
```
$ gcc hello.c -o hello
```
Теперь исполняемый файл будет называться `hello`. Чтобы запустить полученный файл, нужно вбить в терминал путь до этого файла. Поскольку файл находится в той папке, из которой мы сейчас работаем, достаточно просто вбить `./hello`, где `.` означает текущую папку:
```
$ ./hello
Hello world!
```

На самом деле, сборка состоит из многих этапов, давайте разберём основные из них по порядку.

### 1. Препроцессинг
Первый шаг сборки программы на C это исполнение препроцессорных директив - строчек, начинающихся на `#`. В нашем случае это как минимум `#include <stdio.h>`. Препроцессор не знает ничего о тонкостях языка, а просто работает с текстом: он подставит вместо этой строчки содержимое файла `stdio.h`. Можно посмотреть, как именно это будет выглядеть, передав компилятору специальный флаг:
```
$ gcc -E hello.c -o hello-preprocessed.c
```

Это выдаст нам исходный файл, к кторому был применён препроцессор:
```c
// <туча кода из stdio.h>

# 2 "hello.c"
int main() {
    printf("Hello world!\n");
    return 0;
}
```

Вопрос: а что будет, если написать `#include <stdio.h>` дважды? Не запутает ли это компилятор?

Ответ: нет, так как `stdio.h` написан следующим образом:
```c
#ifndef _STDIO_H
#define _STDIO_H	1

// <туча кода>

#endif
```
Поэтому при повторном инклюде компилятор просто выкинет всё содержимое. В вашем коде для аналогичного поведения можно использовать `#pragma once`.

Вопрос: а что за строчка `# 2 "hello.c"`?

Ответ: чтобы понять, попробуем посадить опечатку в исходный файл: заменим `printf` на `printff` и скомпилируем файл после препроцессинга.
```
$ gcc -E hello.c -o hello-preprocessed.c
$ gcc hello-preprocessed.c 
hello.c: In function ‘main’:
hello.c:3:5: warning: implicit declaration of function ‘printff’; did you mean ‘printf’? [-Wimplicit-function-declaration]
    3 |     printff("Hello world!\n");
      |     ^~~~~~~
      |     printf
/usr/bin/ld: /tmp/cc0xOIff.o: in function `main':
hello-preprocessed.c:(.text+0x18): undefined reference to `printff'
collect2: error: ld returned 1 exit status
```
Очень интересно, что `gcc` указывает на ошибку не в том файле, который мы попросили его скомпилировать, а в исходном файле. Именно за это и отвечает данная директива. Если подредактировать исходный код, добавив в него подобную директиву,
```c
#include <stdio.h>

# 42 "somewhere.cpp"
int main() {
    printff("Hello world!\n");
    return 0;
}
```
и попробовать его скомпилировать, то это запутает компилятор и он начнёт указывать на ошибку туда, куда мы его завели:
```
$ gcc hello.c 
somewhere.cpp: In function ‘main’:
somewhere.cpp:43:5: warning: implicit declaration of function ‘printff’; did you mean ‘printf’? [-Wimplicit-function-declaration]
/usr/bin/ld: /tmp/cc3x0A7y.o: in function `main':
hello.c:(.text+0x18): undefined reference to `printff'
collect2: error: ld returned 1 exit status
```
Это может очень сильно усложнить дебаг, так что не делайте так :).

### 2. Непосредственно компиляция
После препроцессинга наступает непосредственно компиляция (зачастую весь процесс сборки называют компиляцией, что может немного запутать), её ещё называют трансляция. На данном этапе по отдельности берётся каждый `.c` файл, полученный после препроцессинга и превращается в набор функций, каждая из которых содержит набор инструкций. Удобнее всего прочитать эти инструкции, когда они выписаны на человеко-читаемом языке, который называют ассемблером. Получить скомпилированный файл на ассемблере можно следующим образом:
```
gcc -S hello-preprocessed.c -o hello.S
```
Тем не менее, читать этот файл самостоятельно я не рекомендую, там очень много шлака, мешающего восприятию. В интернете есть [очень удобный сайт](https://godbolt.org/), который позволяет прочитать только самую суть вашего скомпилированного кода, откинув всё лишнее. Например, для нашего примера получается
```
.LC0:
        .string "Hello world!"
main:
        sub     rsp, 8
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     eax, 0
        add     rsp, 8
        ret
```

### 3. Ассемблирование
Далее компилятор упаковывает получившийся ассемблер в так называемый object file:
```
gcc -c hello.S -o hello.o
```

### 4. Компоновка
Компоновка, она же линковка, это последний этап сборки. В случае с одним объектным файлом не совсем понятно, зачем она нужна и что она делает, так что давайте придумаем искуственный пример, где она будет нам необходима. Допустим, у нас есть функция, которая производит какие-то сложные вычисления (складывает два числа), и мы её определили в отдельном файле. А в `main` мы её используем. Тогда у нас в проекте будет два файла:
```c
// sum.c
float sum(float a, float b) {
    return a + b;
}
```
```c
// hello.c
#include <stdio.h>

int sum(int a, int b);

int main() {
    printf("Hello world! 1 + 2 = %d\n", sum(1, 2));
    return 0;
}
```
Скомпилируем их в объектные файлы:
```
$ gcc -c hello.c -o hello.o
$ gcc -c sum.c -o sum.o
```
Заметим, что мы из одного файла воспользовались функцией из другого файла. То есть в финальном исполняемом файле должна оказаться информация из обоих файлов. Именно для этого линкер и предназначен. На самом деле, линкер это отдельная программа (например, `ld`), однако её нетривиально задать нужные аргументы, так что можно попросить `gcc` сделать это за нас.

```
$ gcc hello.o sum.o -o hello
$ ./hello
Hello world! 1 + 2 = 538673481
```

Слинковалось и запустилось. Но что-то пошло не так. Видите ошибку?

Ошибка в том, что сигнатуры у определения функции в `sum.c` и у декларации в `hello.c` различаются. Компилятор не может этого заметить, так как ни в одном юните трансляции (так называют `.c` файл, пропущенный через препроцессор) эти две противоречащие сигнатуры одновременно не встречаются, а линкер не может этого заметить, так как для него эта функция это просто символ с названием `sum` в обоих случаях.

Именно для этого придумали хедеры (или заголовочные файлы), в которых содержатся декларации функций с их сигнатурами, чтобы они присутствовали во всех юнитах трансляции. Давайте перепишем наш проект с использованием хедера:

```c
// sum.h
#pragma once

int sum(int a, int b);
```
```c
// sum.c
#include "sum.h"

float sum(float a, float b) {
    return a + b;
}
```
```c
// hello.c
#include <stdio.h>
#include "sum.h"

int main() {
    printf("Hello world! 1 + 2 = %d\n", sum(1, 2));
    return 0;
}
```

Теперь попробуем скомпилировать наш проект заново. Хедер компилировать не нужно. Для удобства я не стану снова отдельно компилировать файлы и линковать, а попрошу gcc сделать все эти шаги за меня.

```
$ gcc sum.c hello.c -o hello
sum.c:3:7: error: conflicting types for ‘sum’; have ‘float(float,  float)’
    3 | float sum(float a, float b) {
      |       ^~~
In file included from sum.c:1:
sum.h:3:5: note: previous declaration of ‘sum’ with type ‘int(int,  int)’
    3 | int sum(int a, int b);
      |     ^~~
```

И теперь ошибку нам подсветил компилятор и её можно исправить. Исправление оставляю как упражнение для читателя.

## Статическая и динамическая компоновка

### Статическая линковка
На самом деле, у линкера есть и другие применения. Представьте себе: вы написали библиотеку, которая суммирует два числа и хотите, чтобы её использовали другие люди. Каким образом они могут это сделать? Им определённо понадобится заголовочный файл вашей библиотеки - `sum.h`, но каким образом предлагается распространять сам код? Самый очевидный подход это просто скомпилировать его и выдать пользователю `.o` файл. Но что если в вашей библиотеке много юнитов трансляции? Решением является собрать все эти `.o` файлы в статическую библиотеку. Статическая библиотека это на самом деле просто архив, в котором лежат `.o` файлы. Создать её можно следующим образом:
```
ar rcs libsum.a sum.o
```
Ну и скомпилировать наш код, используя эту библиотеку достаточно просто, нужно лишь указать при сборке флаг `-lsum`. Это означает, что линкер будет искать в папках с библиотеками `libsum.a` или `libsum.so`. Ещё надо указать линкеру, в какой папке лежит эта библиотека. Можно попросить `gcc` сделать это за нас с помощью флага `-L`. Поскольку библиотека у нас лежит в текущей папке, то просто указываем `.`.
```
$ gcc hello.c -L. -lsum -o hello
$ ./hello
Hello world! 1 + 2 = 3
```
Всё работает.

> P.S. Что означают флаги, которые я передал команде `ar`, можно [посмотреть в интернете](https://stackoverflow.com/questions/29714300/what-does-the-rcs-option-in-ar-do).

### Динамическая линковка
Проблема (хотя не все согласятся, что это проблема, так что это скорее нюанс) статической линковки в том, что код библиотеки оказывается намертво вшит в исполняемый файл, это создаёт ряд проблем. Во-первых, частоиспользуемый код приходилось бы дублировать в каждом исполняемом файле, который его использует, что сильно увеличило бы размеры многих утилит. Во-вторых, становится невозможно обновить библиотеку, которой пользуется множество приложений, не обновляя все эти приложения. Или что если на разных системах одни и те же функции должны быть реализованы по-разному? На помощь приходит динамическая линковка!

Динамическая (или разделяемая) библиотека подгружается не только на этапе компиляции, но и в рантайме. Чтобы создать её, нужно передать `gcc` флаги `-shared` и `-fPIC`:
```
$ gcc -shared -fPIC sum.c -o libsum.so
```

Компиляция осуществляется идентичным образом, но при запуске может возникнуть нюанс:
```
$ gcc hello.c -L. -lsum -o hello
$ ./hello
./hello: error while loading shared libraries: libsum.so: cannot open shared object file: No such file or directory
```

Проблема в том, что на этапе компиляции мы указали линкеру, где искать эту библиотеку, а рантайм-линкеру - нет. Исправить это можно двумя способами: либо сообщить рантайм-линкеру, где искать эту библиотеку через переменную окружения:
```
$ LD_LIBRARY_PATH=. ./hello
Hello world! 1 + 2 = 3
```

Либо на этапе линковки задать так называемый `rpath` - путь, где можно будет найти динамические библиотеки в рантайме:
```
$ gcc hello.c -Wl,-rpath=. -L. -lsum -o hello
$ ./hello 
Hello world! 1 + 2 = 3
```

Можно задавать как относительный `rpath`, так и абсолютный.

Напоследок, посмотреть, какие динамические библиотеки используются программой, можно с помощью `ldd`:
```
$ ldd hello
        linux-vdso.so.1 (0x00007ffcd5bf7000)
        libsum.so => ./libsum.so (0x00007fc28cebc000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc28cc8f000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fc28cec8000)
```

## GDB

Ещё одна полезная тулза это дебаггер. Он как правило встроен в IDE, которую вы используете, но давайте попробуем поковыряться с ним напрямую. Я надеюсь, не нужно объяснять, зачем необходим дебаггер - он позволяет понять, какую строчку кода наша программа в данный момент исполняет, а также где она падает. Давайте засадим ошибку в нашей функции `sum` 
```c
// sum.c
#include "sum.h"

int sum(int a, int b) {
    return a / 0;
}
```
и зачем-то проигнорируем ворнинги при сборке с помощью флага `-w`.
> NB: пример игрушечный, никогда не игнорируйте ворнинги в собственном коде
```
$ gcc hello.c sum.c -w -o hello
$ ./hello
Floating point exception
```

Не очень информативно.

Попробуем применить дебаггер. Для этого запустим его, передав ему исполняемый файл через аргумент `exec` и запустим исполнение с помощью `run`, а потом выведем трейс с помощью команды `bt`.

```
$ gdb --exec=./hello
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
<тут служебная информация>
(gdb) run
<ещё служебная информация>
Program received signal SIGFPE, Arithmetic exception.
0x0000555555555194 in ?? ()
(gdb) bt
#0  0x0000555555555194 in ?? ()
#1  0x00007fffffffdd40 in ?? ()
#2  0x0000555555555160 in ?? ()
#3  0x0000000000000001 in ?? ()
#4  0x00007ffff7db7d90 in __libc_start_call_main (main=main@entry=0x555555555149, argc=1, argc@entry=-8912, argv=argv@entry=0x7fffffffde58) at ../sysdeps/nptl/libc_start_call_main.h:58
#5  0x00007ffff7db7e40 in __libc_start_main_impl (main=0x555555555149, argc=-8912, argv=0x7fffffffde58, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde48)
    at ../csu/libc-start.c:392
#6  0x0000555555555085 in ?? ()
#7  0x00007fffffffde48 in ?? ()
#8  0x000000000000001c in ?? ()
#9  0x0000000000000001 in ?? ()
#10 0x00007fffffffe148 in ?? ()
#11 0x0000000000000000 in ?? ()
```

Всё ещё неинформативно. Проблема в том, что `gdb` не может понять, какой строчке в исходном коде ту или иную инструкцию надо сопоставить. Для этого нам потребуются так называемые дебажные символы. Это решается тем, что при компиляции мы передаём флаг `-g`, который добавляет дебажные символы прямо в исполняемый файл. Тогда этот файл можно передать через флаг `--symbol`.

```
$ gcc hello.c sum.c -g -w -o hello-dbg
$ gdb --exec=hello --symbols=hello-dbg
<...>
(gdb) run
<...>
Program received signal SIGFPE, Arithmetic exception.
0x0000555555555194 in sum (a=1, b=2) at sum.c:4
4           return a / 0;
(gdb) bt
#0  0x0000555555555194 in sum (a=1, b=2) at sum.c:4
#1  0x0000555555555160 in main () at hello.c:6
```

Гораздо лучше. Кстати, вы можете создать файл исключительно с символами, выкинув из него сам код, если хотите:
```
strip --only-keep-debug hello
```

> NB: Главное, чтобы файл с символами был скомпилирован с абсолютно теми же флагами, что и тот, который вы дебажите. То есть нельзя использовать символы из Debug сборки, чтобы дебажить Release сборку. Надо именно сделать Release сборку с флагом `-g`.

Последний юзкейс - представьте, что у вас был прод, который работал на протяжении недели, а затем резко умер. Есть ли какие-то способы в такой ситуации воспользоваться дебаггером? Оказывается, можно! Для этого надо (было) перед запуском программы включить core-дампы, у меня на убунте это делается следующим образом:
```
$ sudo sysctl kernel.core_pattern="./coredump"
$ ulimit -c unlimited
```

И потом получившийся core dump передать `gdb`:

```
$ ./hello
Floating point exception (core dumped)
$ gdb --exec=hello --core=coredump --symbol=hello-dbg
<...>
Core was generated by `./hello'.
Program terminated with signal SIGFPE, Arithmetic exception.
#0  0x000055fbda35c194 in sum (a=1, b=2) at sum.c:4
4           return a / 0;
(gdb) bt
#0  0x000055fbda35c194 in sum (a=1, b=2) at sum.c:4
#1  0x000055fbda35c160 in main () at hello.c:6
```

P.S. Вот вам ещё [пара](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf) [ссылок](https://gist.github.com/rkubik/b96c23bd8ed58333de37f2b8cd052c30) со шпаргалками пр GDB

## Санитайзеры
Вообще, настолько тривиальные баги проще отлавливать не дебаггером, а санитайзерами. Санитайзеры инструментируют код, добавляя в него проверки, и красиво репортят вам ошибки, которые происходят в рантайме. В нашем курсе наиболее полезна комбинация `AddressSanitizer` + `UndefinedBehaviorSanitizer`. Подключить их можно с помощью флага `-fsanitize=address,undefined`. Не забываем про `-g`, чтобы санитайзер мог рассказать вам, в какой строчке ошибка.
```
$ gcc hello.c sum.c -w -g -fsanitize=address,undefined -o hello
$ ./hello
sum.c:4:14: runtime error: division by zero
AddressSanitizer:DEADLYSIGNAL
=================================================================
==14150==ERROR: AddressSanitizer: FPE on unknown address 0x563afa8e029b (pc 0x563afa8e029b bp 0x7fff2631ff50 sp 0x7fff2631ff30 T0)
    #0 0x563afa8e029b in sum /home/palych/caos-my/sem-1/sum.c:4
    #1 0x563afa8e01ff in main /home/palych/caos-my/sem-1/hello.c:6
    #2 0x7f2905c9ad8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #3 0x7f2905c9ae3f in __libc_start_main_impl ../csu/libc-start.c:392
    #4 0x563afa8e0124 in _start (/home/palych/caos-my/sem-1/hello+0x1124)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: FPE /home/palych/caos-my/sem-1/sum.c:4 in sum
==14150==ABORTING
```

Кстати, `UndefinedBehaviorSanitizer` почему-то не выводит по умолчанию трейс, но его можно попросить это делать с помощь переменных окружения:
```
export UBSAN_OPTIONS=print_stacktrace=1
```

Есть ещё `ThreadSanitizer`, но он взаимоисключаем с `AddressSanitizer`, так что его мы будем использовать только в определённых ситуациях.

## libc

Давайте начнём с нескольких риторических вопросов.

Вопрос 1: вот некоторое время назад мы говорили, что в заголовочных файлах написаны декларации функций, а не их определения. Например, в файле `stdio.h` мы не найдём определения функции `printf`, которую мы использовали. Где она?

Вопрос 2: когда мы забыли указать файл с символами в дебаггере, то он нам показал куда больший бэктрейс, чем мы видели потом. Что это были за функции?

Вопрос 3: когда мы запускаем программу, у нас сразу `main` начинает исполняться?

Как можно было видеть в выводе команды `ldd` из пункта про динамические библиотеки, `libsum` была не единственной динамической библиотекой, которую мы подгрузили. На самом деле по умолчанию у нас всегда присутствует стандартная библиотека `libc`, в которой реализовано множество полезностей, в том числе и наш `printf`. Это ответ на вопрос 1.

Ответ на вопрос 2: дебаггер можно заставить вывести более полный трейс с помощью команды `set backtrace past-main`. Тогда он выведет следующее:
```
#0  0x000055fbda35c194 in sum (a=1, b=2) at sum.c:4
#1  0x000055fbda35c160 in main () at hello.c:6
#2  0x00007f8d88e33d90 in __libc_start_call_main (main=main@entry=0x55fbda35c149 <main>, argc=argc@entry=1, argv=argv@entry=0x7ffe00c29898) at ../sysdeps/nptl/libc_start_call_main.h:58
#3  0x00007f8d88e33e40 in __libc_start_main_impl (main=0x55fbda35c149 <main>, argc=1, argv=0x7ffe00c29898, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, 
    stack_end=0x7ffe00c29888) at ../csu/libc-start.c:392
#4  0x000055fbda35c085 in _start ()
```

Как видите, здесь виден и ответ на третий вопрос. На самом деле точкой входа является не `main`, а `_start`. Эта процедура реализована в `libc`, и она занимается подготовкой глобальных переменных и аргументов, передаваемых в `main`. Поэтому без `libc` ваш `main` точно не запустится.

Подробнее про это можно почитать по [этой ссылке](http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html) (ну или по крайней мере посмотрите на картиночку).

Кстати, благодаря тому, что в `libc` есть точка входа, её можно запустить как исполняемый файл, и она даже что-то выведет:

```
$ cp /lib/x86_64-linux-gnu/libc.so.6 .
$ chmod +x libc.so.6
$ ./libc.so.6 
GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35.
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
Compiled by GNU CC version 11.2.0.
libc ABIs: UNIQUE IFUNC ABSOLUTE
For bug reporting instructions, please see:
<https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>.
```

## Рекомендуемые флаги компиляции

Когда вы будете решать свои задачки, я рекомендую вам использовать следующие флаги:
```
$ gcc -g -fsanitize=address,undefined -Wall -Wextra
```
Это дебажные символы, санитайзеры и ворнинги, которые помогут вам легче искать и отлавливать ошибки.
